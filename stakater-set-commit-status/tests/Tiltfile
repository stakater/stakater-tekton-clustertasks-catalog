load('ext://helm_resource', 'helm_resource', 'helm_repo')

settings = read_json('../tilt-settings.json', default={})
helm_registry_user = settings.get("helm_registry_user")
helm_registry_pwd = settings.get("helm_registry_pwd")

# if settings.get("allow_k8s_contexts"):
#   allow_k8s_contexts(settings.get("allow_k8s_contexts"))
allow_k8s_contexts('stakater-actions-runner-controller/kubernetes-default-svc:443/system:serviceaccount:stakater-actions-runner-controller:actions-runner-controller-runner-deployment')

# Add helm repos
helm_repo('stakater', 'https://stakater.github.io/stakater-charts')

# Allows a maximum of one resources to update
update_settings (max_parallel_updates = 1)  

# Install Pipelines Operator chart
local_resource(
    'rh-openshift-pipelines-operator', 
    cmd='helm install rh-openshift-pipelines-operator oci://ghcr.io/stakater/charts/rh-openshift-pipelines-operator'
    )

# Wait until Pipelines Operator deployment is in available state
local_resource(
    'wait-for-pipelines-operator-installation',
    cmd="timeout 300s bash -c 'until kubectl wait --for condition=available deployment/openshift-pipelines-operator -n rh-openshift-pipelines-operator; do sleep 10; done'",
    resource_deps=[
        'rh-openshift-pipelines-operator'
    ])

# Install Pipelines Instance chart, a tektonConfig CR which installs Tekton CRDs
local_resource(
    'rh-openshift-pipelines-instance', 
    cmd='helm install rh-openshift-pipelines-instance oci://ghcr.io/stakater/charts/rh-openshift-pipelines-instance',
    resource_deps=[
        'wait-for-pipelines-operator-installation'
    ])

# Wait until all tektonConfig resources are available
local_resource(
    'wait-for-pipelines-instance-installation', 
    cmd='timeout 300s bash -c "until kubectl wait --for condition=Ready tektonconfig/config; do sleep 10; done"',
    resource_deps=[
        'rh-openshift-pipelines-instance'
    ])

# Wait until ClusterTask CRD becomes available before creating CRs
local_resource(
    'wait-for-crds', 
    cmd='timeout 300s bash -c "until kubectl wait --for condition=Established crd/clustertasks.tekton.dev && kubectl wait --for condition=Established crd/taskruns.tekton.dev; do sleep 10; done"',
    resource_deps=[
        'wait-for-pipelines-instance-installation'
    ])

# Create Clustertask
local_resource(
    'clustertask', 
    cmd='helm install clustertask ../helm',
    resource_deps=[
        'wait-for-crds'
    ])

# Create git-token Secret 
local_resource(
    'create-secret', 
    cmd="kubectl create secret generic git-token --from-literal=token={} -n rh-openshift-pipelines-instance".format(str(local('echo -n $TEST_GIT_REPO_SECRET'))),
    resource_deps=[
        'wait-for-pipelines-instance-installation'
    ])

# Create TaskRun & ServiceAccount with hardcoded values to test Clustertask
k8s_yaml(['raw-manifests/taskrun.yaml','raw-manifests/serviceaccount.yaml'])

# Categorize resources
k8s_resource(
    objects=['stakater-set-commit-status:taskrun', 'pipeline:serviceaccount'],
    new_name='TaskRun'
)

# Wait until TaskRun is created
local_resource(
    'check_taskrun',
    cmd="timeout 120s bash -c 'until kubectl wait taskrun/stakater-set-commit-status -n rh-openshift-pipelines-instance --for=jsonpath=\'{.status.conditions[*].type}\'=Succeeded; do sleep 10; done'",
    resource_deps=[
        'TaskRun'
    ]) 

# Run script to test if TaskRun was successful, exit with non-zero code if fails
local_resource(
    'run_script',
    cmd="bash ./taskrun-script.sh",
    resource_deps=[
        'check_taskrun'
    ]) 